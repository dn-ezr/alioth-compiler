---
title: Alioth 0.10 功能清单
author: GodGnidoc
date: 2020/01/15
---

# 0. 文档概述

在长达一年的持续开发过程后，我不得不承认，Alioth 0.9依然不够成功，以至于仍然无法完成开发。经过激烈的思想挣扎，我决定开启Alioth 0.10 再一次重构系统。

Alioth 0.10 的系统重构规模要相较之下小得多，因为所有的外围基础设施已经足够稳定，不需要再进行任何修改。Alioth 0.10需要解决的主要问题是Alioth语法的设计修改，以及与LLVM的对接部分。

Alioth 0.10 将继续使用C++开发，语法分析算法将有所改变以适应新版本中对预览文法的需求。Alioth元素原型的设计一直是Alioth编译器开发成本大幅提高的重要原因之一，在经过深入思考之后，我意识到，元素式的结构设计其实过于复杂，应当简化，并且，我意识到我所谓的元素等概念，实际上与变量等概念一致。

Alioth 0.10 将尝试先编译成为C++语言，实现能自举编译之后，再将自身编译到机器语言。这是将一个漫长的过程。但是发展曲线也变得没那么陡峭了，对于我只有一个人，资历有限的情况，非常合适。

实践证明，我的思想存在诸多错误，然而实践也告诉我，我的方向并没有错误，我不断修改我的错误，不断尝试，直到成功。

- [0. 文档概述](#0-%e6%96%87%e6%a1%a3%e6%a6%82%e8%bf%b0)
- [1. Alioth 0.10 语法设计/概念定义](#1-alioth-010-%e8%af%ad%e6%b3%95%e8%ae%be%e8%ae%a1%e6%a6%82%e5%bf%b5%e5%ae%9a%e4%b9%89)
  - [1.1. 变量](#11-%e5%8f%98%e9%87%8f)
    - [1.1.1. 引用](#111-%e5%bc%95%e7%94%a8)
      - [1.1.2. 实体](#112-%e5%ae%9e%e4%bd%93)
  - [1.2. 类型](#12-%e7%b1%bb%e5%9e%8b)
- [2. Alioth 0.10 语法设计/语法结构](#2-alioth-010-%e8%af%ad%e6%b3%95%e8%ae%be%e8%ae%a1%e8%af%ad%e6%b3%95%e7%bb%93%e6%9e%84)
  - [2.1. 注释](#21-%e6%b3%a8%e9%87%8a)
    - [2.1.1. 单行注释](#211-%e5%8d%95%e8%a1%8c%e6%b3%a8%e9%87%8a)
    - [2.1.2. 多行注释](#212-%e5%a4%9a%e8%a1%8c%e6%b3%a8%e9%87%8a)
  - [2.2. 模块签名](#22-%e6%a8%a1%e5%9d%97%e7%ad%be%e5%90%8d)
    - [2.2.1. 声明模块](#221-%e5%a3%b0%e6%98%8e%e6%a8%a1%e5%9d%97)
    - [2.2.2. 依赖描述符表](#222-%e4%be%9d%e8%b5%96%e6%8f%8f%e8%bf%b0%e7%ac%a6%e8%a1%a8)
    - [2.2.3. 入口标记](#223-%e5%85%a5%e5%8f%a3%e6%a0%87%e8%ae%b0)
  - [2.3. 类定义](#23-%e7%b1%bb%e5%ae%9a%e4%b9%89)
    - [2.3.1. 透明类](#231-%e9%80%8f%e6%98%8e%e7%b1%bb)
- [Appendix A Alioth 0.10 终结词汇表](#appendix-a-alioth-010-%e7%bb%88%e7%bb%93%e8%af%8d%e6%b1%87%e8%a1%a8)

# 1. Alioth 0.10 语法设计/概念定义

## 1.1. 变量

**Alioth**中定义了两种变量作为操作内存中数据的媒介，即`实体`和`引用`。

差别在于，实体变量对类型的检查更为严格，是基于定义的检查，而引用变量对类型的检查则是基于切面的检查；实体变量等价于对象本身，而引用变量则是对对象的引用；

### 1.1.1. 引用

引用的底层实现是一个指向**代理**的指针，而代理的结构如下：

~~~cpp
struct agent {
  void* object;
  void* typeid;
  long  rcount;
}
~~~

代理体的作用是统一引用对对象的生命周期的控制。若代理锁绑定的对象离开作用域，其所属的父对象被销毁，而引用计数仍不为空，则GC系统将移动对象到堆空间管理，延长对象的生命周期。

#### 1.1.2. 实体

实体对象的底层实现可能是对象本身或对象的指针，取决于对象是否为复合结构。

## 1.2. 类型

在**Alioth**中，类的作用是**辅助类型检查**，其附加功能是**辅助构造对象**。

传参时，对象变量的参数类型与实参的类型必须对应，否则报告语义错误。而引用变量的传参规则却极为灵活，只要确保实参拥有形参所有的属性，并且类型正确，传参即可成功。

将方法定义在类中，即可辅助检查`this`的类型，如此便可以为任何满足此类定义的对象调用此方法。

使用`.`运算符可以调用一个对象所属类的方法或一个对象携带的方法。使用`:`运算符可以调用一个当前作用域能找到的方法，将`this`设置为指定对象。

~~~cpp

/** 调用object对象的func方法，对象携带的方法优先级高于对象所属的类中定义的方法 */
object.func()

/** 调用func方法，将object以this的身份传入 */
object:func()
~~~

# 2. Alioth 0.10 语法设计/语法结构

## 2.1. 注释

### 2.1.1. 单行注释

**Alioth**的单行注释由双斜杠开始，到本行结束，样例如下

~~~cpp
//这是单行注释
~~~

### 2.1.2. 多行注释

**Alioth**的多行注释由`/*`开始，由`*/`结束，中间包含的内容被视为注释内容。

~~~cpp
/*
    这里是多行注释的第一行
    这里是多行注释的第二行
*/
~~~

## 2.2. 模块签名

**alioth**程序由模块构成，在编译时，每个模块的内容会被编译到一个对应的**目标单元**。在书写源代码文档时，可以将一个模块的内容拆分放置在若干源文档中，称为**片段**。

### 2.2.1. 声明模块

Alioth源文档需要在第一个有效代码行声明片段所属的模块，语法如下：

~~~alioth
module Hello
~~~

### 2.2.2. 依赖描述符表

模块签名描述了模块名，模块的入口方法，模块的依赖等信息。

依赖描述符表时模块描述符语法结构的一部分，可以用于描述一个模块对其他模块的依赖情况。

~~~alioth
module Hello :
  func // 从本地引用一个模块作为依赖
  string // 若本地不存在此模块，则从alioth包引入此模块
  io @ system // 指定一个包以引用模块
  event @ libev as e // 引用event模块并使用e作为别名
~~~

### 2.2.3. 入口标记

**Alioth**可以为模块指定入口方法作为整个程序的入口，入口描述符也是模块描述符语法结构的一部分。

~~~alioth
module Hello entry main
~~~

入口标记是一个符号，编译器用这个符号去寻找透明类中同名的入口方法。

## 2.3. 类定义

Alioth使用`class`关键字定义类，类的定义不能嵌套。

~~~alioth
class Hello {
    /** 插入内部定义 */
}
~~~

### 2.3.1. 透明类

Alioth中，与模块同名的类称为`透明类`，透明类用于描述模块的属性，方法等。透明类的实现不需要对应的定义，若您不想暴露透明类的方法，可以只实现不声明。

~~~alioth
module Hello entry main

class Hello {
    /** 透明类的定义内容 */
}

method main( argc int32, argv string[] ): int32 {
    /** 主方法 */
}
~~~

# Appendix A Alioth 0.10 终结词汇表

